//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    login(body: LoginRequest, signal?: AbortSignal): Promise<RefreshTokenDto> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<RefreshTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RefreshTokenDto>(null as any);
    }

    /**
     * @return OK
     */
    register(body: RegisterRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    recovery(body: RecoveryRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/recovery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecovery(_response);
        });
    }

    protected processRecovery(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    reset(body: ResetPasswordDto, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/auth/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReset(_response);
        });
    }

    protected processReset(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    verify(token: string, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/auth/verify?";
        if (token === undefined || token === null)
            throw new globalThis.Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    resend(body: ResendVerificationRequest, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/verify/resend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResend(_response);
        });
    }

    protected processResend(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    refresh(body: RefreshTokenRequest, signal?: AbortSignal): Promise<RefreshTokenDto> {
        let url_ = this.baseUrl + "/api/auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<RefreshTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RefreshTokenDto>(null as any);
    }

    /**
     * @return OK
     */
    communitiesAll(signal?: AbortSignal): Promise<CommunityListItemDto[]> {
        let url_ = this.baseUrl + "/api/communities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommunitiesAll(_response);
        });
    }

    protected processCommunitiesAll(response: Response): Promise<CommunityListItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommunityListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommunityListItemDto[]>(null as any);
    }

    /**
     * @return Created
     */
    communitiesPOST(body: CreateCommunityRequestDto, signal?: AbortSignal): Promise<CommunityDetailsDto> {
        let url_ = this.baseUrl + "/api/communities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommunitiesPOST(_response);
        });
    }

    protected processCommunitiesPOST(response: Response): Promise<CommunityDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CommunityDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommunityDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    communitiesGET(id: string, signal?: AbortSignal): Promise<CommunityDetailsDto> {
        let url_ = this.baseUrl + "/api/communities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommunitiesGET(_response);
        });
    }

    protected processCommunitiesGET(response: Response): Promise<CommunityDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommunityDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommunityDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    communitiesPUT(id: string, body: UpdateCommunityRequestDto, signal?: AbortSignal): Promise<CommunityDetailsDto> {
        let url_ = this.baseUrl + "/api/communities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommunitiesPUT(_response);
        });
    }

    protected processCommunitiesPUT(response: Response): Promise<CommunityDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommunityDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommunityDetailsDto>(null as any);
    }

    /**
     * @return No Content
     */
    communitiesDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/communities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommunitiesDELETE(_response);
        });
    }

    protected processCommunitiesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    inviteCode(id: string, signal?: AbortSignal): Promise<InviteCodeResponseDto> {
        let url_ = this.baseUrl + "/api/communities/{id}/invite-code";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInviteCode(_response);
        });
    }

    protected processInviteCode(response: Response): Promise<InviteCodeResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InviteCodeResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InviteCodeResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    rotate(id: string, signal?: AbortSignal): Promise<InviteCodeResponseDto> {
        let url_ = this.baseUrl + "/api/communities/{id}/invite-code/rotate";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRotate(_response);
        });
    }

    protected processRotate(response: Response): Promise<InviteCodeResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InviteCodeResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InviteCodeResponseDto>(null as any);
    }

    /**
     * @return Created
     */
    join(body: JoinCommunityRequestDto, signal?: AbortSignal): Promise<MembershipDetailsDto> {
        let url_ = this.baseUrl + "/api/communities/join";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoin(_response);
        });
    }

    protected processJoin(response: Response): Promise<MembershipDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MembershipDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembershipDetailsDto>(null as any);
    }

    /**
     * @param status (optional) 
     * @param excludingMine (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    feed(id: string, status?: string | undefined, excludingMine?: boolean | undefined, page?: number | undefined, pageSize?: number | undefined, signal?: AbortSignal): Promise<RequestListItemDtoPagedResponseDto> {
        let url_ = this.baseUrl + "/api/communities/{id}/requests/feed?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (excludingMine === null)
            throw new globalThis.Error("The parameter 'excludingMine' cannot be null.");
        else if (excludingMine !== undefined)
            url_ += "excludingMine=" + encodeURIComponent("" + excludingMine) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFeed(_response);
        });
    }

    protected processFeed(response: Response): Promise<RequestListItemDtoPagedResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestListItemDtoPagedResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestListItemDtoPagedResponseDto>(null as any);
    }

    /**
     * @param category (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    available(id: string, category?: string | undefined, page?: number | undefined, pageSize?: number | undefined, signal?: AbortSignal): Promise<ItemListItemDtoPagedResponseDto> {
        let url_ = this.baseUrl + "/api/communities/{id}/items/available?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (category === null)
            throw new globalThis.Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAvailable(_response);
        });
    }

    protected processAvailable(response: Response): Promise<ItemListItemDtoPagedResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ItemListItemDtoPagedResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ItemListItemDtoPagedResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    inviteLink(id: string, signal?: AbortSignal): Promise<InviteLinkResponseDto> {
        let url_ = this.baseUrl + "/api/communities/{id}/invite-link";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInviteLink(_response);
        });
    }

    protected processInviteLink(response: Response): Promise<InviteLinkResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InviteLinkResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InviteLinkResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    eventsAll(signal?: AbortSignal): Promise<EventListItemDto[]> {
        let url_ = this.baseUrl + "/api/events";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEventsAll(_response);
        });
    }

    protected processEventsAll(response: Response): Promise<EventListItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventListItemDto[]>(null as any);
    }

    /**
     * @return Created
     */
    eventsPOST(body: CreateEventRequestDto, signal?: AbortSignal): Promise<EventDetailsDto> {
        let url_ = this.baseUrl + "/api/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEventsPOST(_response);
        });
    }

    protected processEventsPOST(response: Response): Promise<EventDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EventDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    eventsGET(id: string, signal?: AbortSignal): Promise<EventDetailsDto> {
        let url_ = this.baseUrl + "/api/events/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEventsGET(_response);
        });
    }

    protected processEventsGET(response: Response): Promise<EventDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    eventsPUT(id: string, body: UpdateEventRequestDto, signal?: AbortSignal): Promise<EventDetailsDto> {
        let url_ = this.baseUrl + "/api/events/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEventsPUT(_response);
        });
    }

    protected processEventsPUT(response: Response): Promise<EventDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EventDetailsDto>(null as any);
    }

    /**
     * @return No Content
     */
    eventsDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/events/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEventsDELETE(_response);
        });
    }

    protected processEventsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param communityId (optional) 
     * @return OK
     */
    itemsAll(communityId?: string | undefined, signal?: AbortSignal): Promise<ItemListItemDto[]> {
        let url_ = this.baseUrl + "/api/items?";
        if (communityId === null)
            throw new globalThis.Error("The parameter 'communityId' cannot be null.");
        else if (communityId !== undefined)
            url_ += "communityId=" + encodeURIComponent("" + communityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItemsAll(_response);
        });
    }

    protected processItemsAll(response: Response): Promise<ItemListItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ItemListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ItemListItemDto[]>(null as any);
    }

    /**
     * @return Created
     */
    itemsPOST(body: CreateItemRequestDto, signal?: AbortSignal): Promise<ItemDetailsDto> {
        let url_ = this.baseUrl + "/api/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItemsPOST(_response);
        });
    }

    protected processItemsPOST(response: Response): Promise<ItemDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ItemDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ItemDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    itemsGET(id: string, signal?: AbortSignal): Promise<ItemDetailsDto> {
        let url_ = this.baseUrl + "/api/items/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItemsGET(_response);
        });
    }

    protected processItemsGET(response: Response): Promise<ItemDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ItemDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ItemDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    itemsPUT(id: string, body: UpdateItemRequestDto, signal?: AbortSignal): Promise<ItemDetailsDto> {
        let url_ = this.baseUrl + "/api/items/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItemsPUT(_response);
        });
    }

    protected processItemsPUT(response: Response): Promise<ItemDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ItemDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ItemDetailsDto>(null as any);
    }

    /**
     * @return No Content
     */
    itemsDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/items/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItemsDELETE(_response);
        });
    }

    protected processItemsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param communityId (optional) 
     * @param status (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    loansGET(communityId?: string | undefined, status?: string | undefined, from?: Date | undefined, to?: Date | undefined, page?: number | undefined, pageSize?: number | undefined, signal?: AbortSignal): Promise<LoanListItemDtoPagedResponseDto> {
        let url_ = this.baseUrl + "/api/loans?";
        if (communityId === null)
            throw new globalThis.Error("The parameter 'communityId' cannot be null.");
        else if (communityId !== undefined)
            url_ += "communityId=" + encodeURIComponent("" + communityId) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (from === null)
            throw new globalThis.Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new globalThis.Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoansGET(_response);
        });
    }

    protected processLoansGET(response: Response): Promise<LoanListItemDtoPagedResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanListItemDtoPagedResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanListItemDtoPagedResponseDto>(null as any);
    }

    /**
     * @return Created
     */
    loansPOST(body: CreateLoanRequestDto, signal?: AbortSignal): Promise<LoanDetailsDto> {
        let url_ = this.baseUrl + "/api/loans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoansPOST(_response);
        });
    }

    protected processLoansPOST(response: Response): Promise<LoanDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LoanDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    loansGET2(id: string, signal?: AbortSignal): Promise<LoanDetailsDto> {
        let url_ = this.baseUrl + "/api/loans/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoansGET2(_response);
        });
    }

    protected processLoansGET2(response: Response): Promise<LoanDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    loansPUT(id: string, body: UpdateLoanRequestDto, signal?: AbortSignal): Promise<LoanDetailsDto> {
        let url_ = this.baseUrl + "/api/loans/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoansPUT(_response);
        });
    }

    protected processLoansPUT(response: Response): Promise<LoanDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanDetailsDto>(null as any);
    }

    /**
     * @return No Content
     */
    loansDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/loans/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoansDELETE(_response);
        });
    }

    protected processLoansDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    start(id: string, signal?: AbortSignal): Promise<LoanDetailsDto> {
        let url_ = this.baseUrl + "/api/loans/{id}/start";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStart(_response);
        });
    }

    protected processStart(response: Response): Promise<LoanDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    returnRequest(id: string, signal?: AbortSignal): Promise<LoanDetailsDto> {
        let url_ = this.baseUrl + "/api/loans/{id}/return-request";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReturnRequest(_response);
        });
    }

    protected processReturnRequest(response: Response): Promise<LoanDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    returnConfirm(id: string, signal?: AbortSignal): Promise<LoanDetailsDto> {
        let url_ = this.baseUrl + "/api/loans/{id}/return-confirm";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReturnConfirm(_response);
        });
    }

    protected processReturnConfirm(response: Response): Promise<LoanDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    returnCancel(id: string, signal?: AbortSignal): Promise<LoanDetailsDto> {
        let url_ = this.baseUrl + "/api/loans/{id}/return-cancel";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReturnCancel(_response);
        });
    }

    protected processReturnCancel(response: Response): Promise<LoanDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    membershipsAll(signal?: AbortSignal): Promise<MembershipListItemDto[]> {
        let url_ = this.baseUrl + "/api/memberships";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembershipsAll(_response);
        });
    }

    protected processMembershipsAll(response: Response): Promise<MembershipListItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MembershipListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembershipListItemDto[]>(null as any);
    }

    /**
     * @return Created
     */
    membershipsPOST(body: CreateMembershipRequestDto, signal?: AbortSignal): Promise<MembershipDetailsDto> {
        let url_ = this.baseUrl + "/api/memberships";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembershipsPOST(_response);
        });
    }

    protected processMembershipsPOST(response: Response): Promise<MembershipDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MembershipDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembershipDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    meAll(signal?: AbortSignal): Promise<MembershipListItemDto[]> {
        let url_ = this.baseUrl + "/api/memberships/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeAll(_response);
        });
    }

    protected processMeAll(response: Response): Promise<MembershipListItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MembershipListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembershipListItemDto[]>(null as any);
    }

    /**
     * @return OK
     */
    communitiesAll2(signal?: AbortSignal): Promise<CommunityListItemDto[]> {
        let url_ = this.baseUrl + "/api/memberships/me/communities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommunitiesAll2(_response);
        });
    }

    protected processCommunitiesAll2(response: Response): Promise<CommunityListItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommunityListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommunityListItemDto[]>(null as any);
    }

    /**
     * @return OK
     */
    membershipsGET(id: string, signal?: AbortSignal): Promise<MembershipDetailsDto> {
        let url_ = this.baseUrl + "/api/memberships/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembershipsGET(_response);
        });
    }

    protected processMembershipsGET(response: Response): Promise<MembershipDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MembershipDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembershipDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    membershipsPUT(id: string, body: UpdateMembershipRequestDto, signal?: AbortSignal): Promise<MembershipDetailsDto> {
        let url_ = this.baseUrl + "/api/memberships/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembershipsPUT(_response);
        });
    }

    protected processMembershipsPUT(response: Response): Promise<MembershipDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MembershipDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembershipDetailsDto>(null as any);
    }

    /**
     * @return No Content
     */
    membershipsDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/memberships/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembershipsDELETE(_response);
        });
    }

    protected processMembershipsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    role(id: string, body: UpdateMembershipRoleRequestDto, signal?: AbortSignal): Promise<MembershipDetailsDto> {
        let url_ = this.baseUrl + "/api/memberships/{id}/role";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRole(_response);
        });
    }

    protected processRole(response: Response): Promise<MembershipDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MembershipDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MembershipDetailsDto>(null as any);
    }

    /**
     * @return No Content
     */
    leave(communityId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/memberships/leave/{communityId}";
        if (communityId === undefined || communityId === null)
            throw new globalThis.Error("The parameter 'communityId' must be defined.");
        url_ = url_.replace("{communityId}", encodeURIComponent("" + communityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeave(_response);
        });
    }

    protected processLeave(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param communityId (optional) 
     * @param unreadOnly (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    notifications(communityId?: string | undefined, unreadOnly?: boolean | undefined, page?: number | undefined, pageSize?: number | undefined, signal?: AbortSignal): Promise<NotificationListItemDtoPagedResult> {
        let url_ = this.baseUrl + "/api/notifications?";
        if (communityId === null)
            throw new globalThis.Error("The parameter 'communityId' cannot be null.");
        else if (communityId !== undefined)
            url_ += "communityId=" + encodeURIComponent("" + communityId) + "&";
        if (unreadOnly === null)
            throw new globalThis.Error("The parameter 'unreadOnly' cannot be null.");
        else if (unreadOnly !== undefined)
            url_ += "unreadOnly=" + encodeURIComponent("" + unreadOnly) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications(_response);
        });
    }

    protected processNotifications(response: Response): Promise<NotificationListItemDtoPagedResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationListItemDtoPagedResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationListItemDtoPagedResult>(null as any);
    }

    /**
     * @return OK
     */
    notifications2(id: string, signal?: AbortSignal): Promise<NotificationDetailsDto> {
        let url_ = this.baseUrl + "/api/notifications/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications2(_response);
        });
    }

    protected processNotifications2(response: Response): Promise<NotificationDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    read(id: string, signal?: AbortSignal): Promise<NotificationDetailsDto> {
        let url_ = this.baseUrl + "/api/notifications/{id}/read";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRead(_response);
        });
    }

    protected processRead(response: Response): Promise<NotificationDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    readAll(body: NotificationMarkReadRequestDto, signal?: AbortSignal): Promise<NotificationDetailsDto[]> {
        let url_ = this.baseUrl + "/api/notifications/read";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReadAll(_response);
        });
    }

    protected processReadAll(response: Response): Promise<NotificationDetailsDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationDetailsDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationDetailsDto[]>(null as any);
    }

    /**
     * @param communityId (optional) 
     * @return OK
     */
    unreadCount(communityId?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/unread-count?";
        if (communityId === null)
            throw new globalThis.Error("The parameter 'communityId' cannot be null.");
        else if (communityId !== undefined)
            url_ += "communityId=" + encodeURIComponent("" + communityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnreadCount(_response);
        });
    }

    protected processUnreadCount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    offersAll(signal?: AbortSignal): Promise<OfferListItemDto[]> {
        let url_ = this.baseUrl + "/api/offers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOffersAll(_response);
        });
    }

    protected processOffersAll(response: Response): Promise<OfferListItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OfferListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfferListItemDto[]>(null as any);
    }

    /**
     * @return Created
     */
    offersPOST(body: CreateOfferRequestDto, signal?: AbortSignal): Promise<OfferDetailsDto> {
        let url_ = this.baseUrl + "/api/offers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOffersPOST(_response);
        });
    }

    protected processOffersPOST(response: Response): Promise<OfferDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OfferDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfferDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    offersGET(id: string, signal?: AbortSignal): Promise<OfferDetailsDto> {
        let url_ = this.baseUrl + "/api/offers/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOffersGET(_response);
        });
    }

    protected processOffersGET(response: Response): Promise<OfferDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfferDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    offersPUT(id: string, body: UpdateOfferRequestDto, signal?: AbortSignal): Promise<OfferDetailsDto> {
        let url_ = this.baseUrl + "/api/offers/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOffersPUT(_response);
        });
    }

    protected processOffersPUT(response: Response): Promise<OfferDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfferDetailsDto>(null as any);
    }

    /**
     * @return No Content
     */
    offersDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/offers/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOffersDELETE(_response);
        });
    }

    protected processOffersDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param communityId (optional) 
     * @param status (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    me(communityId?: string | undefined, status?: string | undefined, page?: number | undefined, pageSize?: number | undefined, signal?: AbortSignal): Promise<OfferListItemDtoPagedResponseDto> {
        let url_ = this.baseUrl + "/api/offers/me?";
        if (communityId === null)
            throw new globalThis.Error("The parameter 'communityId' cannot be null.");
        else if (communityId !== undefined)
            url_ += "communityId=" + encodeURIComponent("" + communityId) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: Response): Promise<OfferListItemDtoPagedResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferListItemDtoPagedResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfferListItemDtoPagedResponseDto>(null as any);
    }

    /**
     * @return Created
     */
    accept(id: string, body: AcceptOfferRequestDto, signal?: AbortSignal): Promise<LoanDetailsDto> {
        let url_ = this.baseUrl + "/api/offers/{id}/accept";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccept(_response);
        });
    }

    protected processAccept(response: Response): Promise<LoanDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LoanDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoanDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    reject(id: string, signal?: AbortSignal): Promise<OfferStatusResponseDto> {
        let url_ = this.baseUrl + "/api/offers/{id}/reject";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReject(_response);
        });
    }

    protected processReject(response: Response): Promise<OfferStatusResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferStatusResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfferStatusResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    withdraw(id: string, signal?: AbortSignal): Promise<OfferStatusResponseDto> {
        let url_ = this.baseUrl + "/api/offers/{id}/withdraw";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithdraw(_response);
        });
    }

    protected processWithdraw(response: Response): Promise<OfferStatusResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferStatusResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfferStatusResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    me2(communityId: string, signal?: AbortSignal): Promise<ReputationDetailsDto> {
        let url_ = this.baseUrl + "/api/reputation/{communityId}/me";
        if (communityId === undefined || communityId === null)
            throw new globalThis.Error("The parameter 'communityId' must be defined.");
        url_ = url_.replace("{communityId}", encodeURIComponent("" + communityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMe2(_response);
        });
    }

    protected processMe2(response: Response): Promise<ReputationDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReputationDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReputationDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    users(communityId: string, userId: string, signal?: AbortSignal): Promise<ReputationDetailsDto> {
        let url_ = this.baseUrl + "/api/reputation/{communityId}/users/{userId}";
        if (communityId === undefined || communityId === null)
            throw new globalThis.Error("The parameter 'communityId' must be defined.");
        url_ = url_.replace("{communityId}", encodeURIComponent("" + communityId));
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(response: Response): Promise<ReputationDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReputationDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReputationDetailsDto>(null as any);
    }

    /**
     * @param communityId (optional) 
     * @return OK
     */
    requestsAll(communityId?: string | undefined, signal?: AbortSignal): Promise<RequestListItemDto[]> {
        let url_ = this.baseUrl + "/api/requests?";
        if (communityId === null)
            throw new globalThis.Error("The parameter 'communityId' cannot be null.");
        else if (communityId !== undefined)
            url_ += "communityId=" + encodeURIComponent("" + communityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsAll(_response);
        });
    }

    protected processRequestsAll(response: Response): Promise<RequestListItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestListItemDto[]>(null as any);
    }

    /**
     * @return Created
     */
    requestsPOST(body: CreateRequestRequestDto, signal?: AbortSignal): Promise<RequestDetailsDto> {
        let url_ = this.baseUrl + "/api/requests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsPOST(_response);
        });
    }

    protected processRequestsPOST(response: Response): Promise<RequestDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RequestDetailsDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    requestsGET(id: string, signal?: AbortSignal): Promise<RequestDetailsDto> {
        let url_ = this.baseUrl + "/api/requests/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsGET(_response);
        });
    }

    protected processRequestsGET(response: Response): Promise<RequestDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestDetailsDto>(null as any);
    }

    /**
     * @return OK
     */
    requestsPUT(id: string, body: UpdateRequestRequestDto, signal?: AbortSignal): Promise<RequestDetailsDto> {
        let url_ = this.baseUrl + "/api/requests/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsPUT(_response);
        });
    }

    protected processRequestsPUT(response: Response): Promise<RequestDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestDetailsDto>(null as any);
    }

    /**
     * @return No Content
     */
    requestsDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/requests/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestsDELETE(_response);
        });
    }

    protected processRequestsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    offersGET2(id: string, page?: number | undefined, pageSize?: number | undefined, signal?: AbortSignal): Promise<OfferListItemDtoPagedResponseDto> {
        let url_ = this.baseUrl + "/api/requests/{id}/offers?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOffersGET2(_response);
        });
    }

    protected processOffersGET2(response: Response): Promise<OfferListItemDtoPagedResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OfferListItemDtoPagedResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfferListItemDtoPagedResponseDto>(null as any);
    }

    /**
     * @param communityId (optional) 
     * @param status (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    me3(communityId?: string | undefined, status?: string | undefined, page?: number | undefined, pageSize?: number | undefined, signal?: AbortSignal): Promise<RequestListItemDtoPagedResponseDto> {
        let url_ = this.baseUrl + "/api/requests/me?";
        if (communityId === null)
            throw new globalThis.Error("The parameter 'communityId' cannot be null.");
        else if (communityId !== undefined)
            url_ += "communityId=" + encodeURIComponent("" + communityId) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMe3(_response);
        });
    }

    protected processMe3(response: Response): Promise<RequestListItemDtoPagedResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestListItemDtoPagedResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestListItemDtoPagedResponseDto>(null as any);
    }
}

export class AcceptOfferRequestDto implements IAcceptOfferRequestDto {
    borrowerUserId?: string | undefined;

    constructor(data?: IAcceptOfferRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.borrowerUserId = _data["borrowerUserId"];
        }
    }

    static fromJS(data: any): AcceptOfferRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptOfferRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["borrowerUserId"] = this.borrowerUserId;
        return data;
    }
}

export interface IAcceptOfferRequestDto {
    borrowerUserId?: string | undefined;
}

export class AccessTokenResult implements IAccessTokenResult {
    token?: string | undefined;
    expiresInSeconds?: number;

    constructor(data?: IAccessTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.expiresInSeconds = _data["expiresInSeconds"];
        }
    }

    static fromJS(data: any): AccessTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expiresInSeconds"] = this.expiresInSeconds;
        return data;
    }
}

export interface IAccessTokenResult {
    token?: string | undefined;
    expiresInSeconds?: number;
}

export class CommunityDetailsDto implements ICommunityDetailsDto {
    id?: string | undefined;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdByUserId?: string | undefined;
    createdAt?: Date;

    constructor(data?: ICommunityDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.createdByUserId = _data["createdByUserId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CommunityDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommunityDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["createdByUserId"] = this.createdByUserId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ICommunityDetailsDto {
    id?: string | undefined;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdByUserId?: string | undefined;
    createdAt?: Date;
}

export class CommunityListItemDto implements ICommunityListItemDto {
    id?: string | undefined;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdByUserId?: string | undefined;
    createdAt?: Date;

    constructor(data?: ICommunityListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.createdByUserId = _data["createdByUserId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CommunityListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommunityListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["createdByUserId"] = this.createdByUserId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ICommunityListItemDto {
    id?: string | undefined;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    createdByUserId?: string | undefined;
    createdAt?: Date;
}

export class CommunitySummaryDto implements ICommunitySummaryDto {
    id?: string | undefined;
    name?: string | undefined;
    slug?: string | undefined;

    constructor(data?: ICommunitySummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): CommunitySummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommunitySummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface ICommunitySummaryDto {
    id?: string | undefined;
    name?: string | undefined;
    slug?: string | undefined;
}

export class CreateCommunityRequestDto implements ICreateCommunityRequestDto {
    name?: string | undefined;
    slug?: string | undefined;
    createdByUserId?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateCommunityRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.createdByUserId = _data["createdByUserId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCommunityRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommunityRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["createdByUserId"] = this.createdByUserId;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateCommunityRequestDto {
    name?: string | undefined;
    slug?: string | undefined;
    createdByUserId?: string | undefined;
    description?: string | undefined;
}

export class CreateEventRequestDto implements ICreateEventRequestDto {
    communityId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    action?: string | undefined;
    payload?: string | undefined;

    constructor(data?: ICreateEventRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.action = _data["action"];
            this.payload = _data["payload"];
        }
    }

    static fromJS(data: any): CreateEventRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["action"] = this.action;
        data["payload"] = this.payload;
        return data;
    }
}

export interface ICreateEventRequestDto {
    communityId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    action?: string | undefined;
    payload?: string | undefined;
}

export class CreateItemRequestDto implements ICreateItemRequestDto {
    communityId?: string | undefined;
    ownerUserId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;

    constructor(data?: ICreateItemRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.ownerUserId = _data["ownerUserId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateItemRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateItemRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["ownerUserId"] = this.ownerUserId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateItemRequestDto {
    communityId?: string | undefined;
    ownerUserId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;
}

export class CreateLoanRequestDto implements ICreateLoanRequestDto {
    communityId?: string | undefined;
    itemId?: string | undefined;
    lenderUserId?: string | undefined;
    borrowerUserId?: string | undefined;
    requestId?: string | undefined;
    offerId?: string | undefined;
    status?: string | undefined;
    startAt?: Date | undefined;
    dueAt?: Date | undefined;

    constructor(data?: ICreateLoanRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.itemId = _data["itemId"];
            this.lenderUserId = _data["lenderUserId"];
            this.borrowerUserId = _data["borrowerUserId"];
            this.requestId = _data["requestId"];
            this.offerId = _data["offerId"];
            this.status = _data["status"];
            this.startAt = _data["startAt"] ? new Date(_data["startAt"].toString()) : undefined as any;
            this.dueAt = _data["dueAt"] ? new Date(_data["dueAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CreateLoanRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLoanRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["itemId"] = this.itemId;
        data["lenderUserId"] = this.lenderUserId;
        data["borrowerUserId"] = this.borrowerUserId;
        data["requestId"] = this.requestId;
        data["offerId"] = this.offerId;
        data["status"] = this.status;
        data["startAt"] = this.startAt ? this.startAt.toISOString() : undefined as any;
        data["dueAt"] = this.dueAt ? this.dueAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ICreateLoanRequestDto {
    communityId?: string | undefined;
    itemId?: string | undefined;
    lenderUserId?: string | undefined;
    borrowerUserId?: string | undefined;
    requestId?: string | undefined;
    offerId?: string | undefined;
    status?: string | undefined;
    startAt?: Date | undefined;
    dueAt?: Date | undefined;
}

export class CreateMembershipRequestDto implements ICreateMembershipRequestDto {
    communityId?: string | undefined;
    enterCode?: string | undefined;

    constructor(data?: ICreateMembershipRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.enterCode = _data["enterCode"];
        }
    }

    static fromJS(data: any): CreateMembershipRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMembershipRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["enterCode"] = this.enterCode;
        return data;
    }
}

export interface ICreateMembershipRequestDto {
    communityId?: string | undefined;
    enterCode?: string | undefined;
}

export class CreateOfferRequestDto implements ICreateOfferRequestDto {
    communityId?: string | undefined;
    offererUserId?: string | undefined;
    requestId?: string | undefined;
    itemId?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;

    constructor(data?: ICreateOfferRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.offererUserId = _data["offererUserId"];
            this.requestId = _data["requestId"];
            this.itemId = _data["itemId"];
            this.message = _data["message"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateOfferRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOfferRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["offererUserId"] = this.offererUserId;
        data["requestId"] = this.requestId;
        data["itemId"] = this.itemId;
        data["message"] = this.message;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateOfferRequestDto {
    communityId?: string | undefined;
    offererUserId?: string | undefined;
    requestId?: string | undefined;
    itemId?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;
}

export class CreateRequestRequestDto implements ICreateRequestRequestDto {
    communityId?: string | undefined;
    requesterUserId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    neededFrom?: Date | undefined;
    neededTo?: Date | undefined;

    constructor(data?: ICreateRequestRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.requesterUserId = _data["requesterUserId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.neededFrom = _data["neededFrom"] ? new Date(_data["neededFrom"].toString()) : undefined as any;
            this.neededTo = _data["neededTo"] ? new Date(_data["neededTo"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CreateRequestRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRequestRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["requesterUserId"] = this.requesterUserId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["status"] = this.status;
        data["neededFrom"] = this.neededFrom ? this.neededFrom.toISOString() : undefined as any;
        data["neededTo"] = this.neededTo ? this.neededTo.toISOString() : undefined as any;
        return data;
    }
}

export interface ICreateRequestRequestDto {
    communityId?: string | undefined;
    requesterUserId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    neededFrom?: Date | undefined;
    neededTo?: Date | undefined;
}

export class EventDetailsDto implements IEventDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    actorUserId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    action?: string | undefined;
    payload?: string | undefined;
    createdAt?: Date;

    constructor(data?: IEventDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.actorUserId = _data["actorUserId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.action = _data["action"];
            this.payload = _data["payload"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): EventDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["actorUserId"] = this.actorUserId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["action"] = this.action;
        data["payload"] = this.payload;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IEventDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    actorUserId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    action?: string | undefined;
    payload?: string | undefined;
    createdAt?: Date;
}

export class EventListItemDto implements IEventListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    actorUserId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    action?: string | undefined;
    payload?: string | undefined;
    createdAt?: Date;

    constructor(data?: IEventListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.actorUserId = _data["actorUserId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.action = _data["action"];
            this.payload = _data["payload"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): EventListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["actorUserId"] = this.actorUserId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["action"] = this.action;
        data["payload"] = this.payload;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IEventListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    actorUserId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    action?: string | undefined;
    payload?: string | undefined;
    createdAt?: Date;
}

export class InviteCodeResponseDto implements IInviteCodeResponseDto {
    enterCode?: string | undefined;
    expiresAt?: Date;

    constructor(data?: IInviteCodeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enterCode = _data["enterCode"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): InviteCodeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InviteCodeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enterCode"] = this.enterCode;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IInviteCodeResponseDto {
    enterCode?: string | undefined;
    expiresAt?: Date;
}

export class InviteLinkResponseDto implements IInviteLinkResponseDto {
    url?: string | undefined;
    expiresAt?: Date;

    constructor(data?: IInviteLinkResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): InviteLinkResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InviteLinkResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IInviteLinkResponseDto {
    url?: string | undefined;
    expiresAt?: Date;
}

export class ItemDetailsDto implements IItemDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    ownerUserId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    owner?: UserSummaryDto;

    constructor(data?: IItemDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.ownerUserId = _data["ownerUserId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.owner = _data["owner"] ? UserSummaryDto.fromJS(_data["owner"]) : undefined as any;
        }
    }

    static fromJS(data: any): ItemDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["ownerUserId"] = this.ownerUserId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["owner"] = this.owner ? this.owner.toJSON() : undefined as any;
        return data;
    }
}

export interface IItemDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    ownerUserId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    owner?: UserSummaryDto;
}

export class ItemListItemDto implements IItemListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    ownerUserId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    owner?: UserSummaryDto;

    constructor(data?: IItemListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.ownerUserId = _data["ownerUserId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.owner = _data["owner"] ? UserSummaryDto.fromJS(_data["owner"]) : undefined as any;
        }
    }

    static fromJS(data: any): ItemListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["ownerUserId"] = this.ownerUserId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["owner"] = this.owner ? this.owner.toJSON() : undefined as any;
        return data;
    }
}

export interface IItemListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    ownerUserId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    owner?: UserSummaryDto;
}

export class ItemListItemDtoPagedResponseDto implements IItemListItemDtoPagedResponseDto {
    items?: ItemListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;

    constructor(data?: IItemListItemDtoPagedResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ItemListItemDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ItemListItemDtoPagedResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemListItemDtoPagedResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        return data;
    }
}

export interface IItemListItemDtoPagedResponseDto {
    items?: ItemListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;
}

export class ItemSummaryDto implements IItemSummaryDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;
    ownerUserId?: string | undefined;

    constructor(data?: IItemSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.status = _data["status"];
            this.ownerUserId = _data["ownerUserId"];
        }
    }

    static fromJS(data: any): ItemSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["status"] = this.status;
        data["ownerUserId"] = this.ownerUserId;
        return data;
    }
}

export interface IItemSummaryDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;
    ownerUserId?: string | undefined;
}

export class JoinCommunityRequestDto implements IJoinCommunityRequestDto {
    enterCode?: string | undefined;

    constructor(data?: IJoinCommunityRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enterCode = _data["enterCode"];
        }
    }

    static fromJS(data: any): JoinCommunityRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new JoinCommunityRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enterCode"] = this.enterCode;
        return data;
    }
}

export interface IJoinCommunityRequestDto {
    enterCode?: string | undefined;
}

export class LoanDetailsDto implements ILoanDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    itemId?: string | undefined;
    lenderUserId?: string | undefined;
    borrowerUserId?: string | undefined;
    requestId?: string | undefined;
    offerId?: string | undefined;
    status?: string | undefined;
    startAt?: Date;
    dueAt?: Date | undefined;
    returnedAt?: Date | undefined;
    returnRequestedAt?: Date | undefined;
    returnConfirmedAt?: Date | undefined;
    lender?: UserSummaryDto;
    borrower?: UserSummaryDto;
    item?: ItemSummaryDto;

    constructor(data?: ILoanDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.itemId = _data["itemId"];
            this.lenderUserId = _data["lenderUserId"];
            this.borrowerUserId = _data["borrowerUserId"];
            this.requestId = _data["requestId"];
            this.offerId = _data["offerId"];
            this.status = _data["status"];
            this.startAt = _data["startAt"] ? new Date(_data["startAt"].toString()) : undefined as any;
            this.dueAt = _data["dueAt"] ? new Date(_data["dueAt"].toString()) : undefined as any;
            this.returnedAt = _data["returnedAt"] ? new Date(_data["returnedAt"].toString()) : undefined as any;
            this.returnRequestedAt = _data["returnRequestedAt"] ? new Date(_data["returnRequestedAt"].toString()) : undefined as any;
            this.returnConfirmedAt = _data["returnConfirmedAt"] ? new Date(_data["returnConfirmedAt"].toString()) : undefined as any;
            this.lender = _data["lender"] ? UserSummaryDto.fromJS(_data["lender"]) : undefined as any;
            this.borrower = _data["borrower"] ? UserSummaryDto.fromJS(_data["borrower"]) : undefined as any;
            this.item = _data["item"] ? ItemSummaryDto.fromJS(_data["item"]) : undefined as any;
        }
    }

    static fromJS(data: any): LoanDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoanDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["itemId"] = this.itemId;
        data["lenderUserId"] = this.lenderUserId;
        data["borrowerUserId"] = this.borrowerUserId;
        data["requestId"] = this.requestId;
        data["offerId"] = this.offerId;
        data["status"] = this.status;
        data["startAt"] = this.startAt ? this.startAt.toISOString() : undefined as any;
        data["dueAt"] = this.dueAt ? this.dueAt.toISOString() : undefined as any;
        data["returnedAt"] = this.returnedAt ? this.returnedAt.toISOString() : undefined as any;
        data["returnRequestedAt"] = this.returnRequestedAt ? this.returnRequestedAt.toISOString() : undefined as any;
        data["returnConfirmedAt"] = this.returnConfirmedAt ? this.returnConfirmedAt.toISOString() : undefined as any;
        data["lender"] = this.lender ? this.lender.toJSON() : undefined as any;
        data["borrower"] = this.borrower ? this.borrower.toJSON() : undefined as any;
        data["item"] = this.item ? this.item.toJSON() : undefined as any;
        return data;
    }
}

export interface ILoanDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    itemId?: string | undefined;
    lenderUserId?: string | undefined;
    borrowerUserId?: string | undefined;
    requestId?: string | undefined;
    offerId?: string | undefined;
    status?: string | undefined;
    startAt?: Date;
    dueAt?: Date | undefined;
    returnedAt?: Date | undefined;
    returnRequestedAt?: Date | undefined;
    returnConfirmedAt?: Date | undefined;
    lender?: UserSummaryDto;
    borrower?: UserSummaryDto;
    item?: ItemSummaryDto;
}

export class LoanListItemDto implements ILoanListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    itemId?: string | undefined;
    lenderUserId?: string | undefined;
    borrowerUserId?: string | undefined;
    requestId?: string | undefined;
    offerId?: string | undefined;
    status?: string | undefined;
    startAt?: Date;
    dueAt?: Date | undefined;
    returnedAt?: Date | undefined;
    returnRequestedAt?: Date | undefined;
    returnConfirmedAt?: Date | undefined;
    lender?: UserSummaryDto;
    borrower?: UserSummaryDto;
    item?: ItemSummaryDto;

    constructor(data?: ILoanListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.itemId = _data["itemId"];
            this.lenderUserId = _data["lenderUserId"];
            this.borrowerUserId = _data["borrowerUserId"];
            this.requestId = _data["requestId"];
            this.offerId = _data["offerId"];
            this.status = _data["status"];
            this.startAt = _data["startAt"] ? new Date(_data["startAt"].toString()) : undefined as any;
            this.dueAt = _data["dueAt"] ? new Date(_data["dueAt"].toString()) : undefined as any;
            this.returnedAt = _data["returnedAt"] ? new Date(_data["returnedAt"].toString()) : undefined as any;
            this.returnRequestedAt = _data["returnRequestedAt"] ? new Date(_data["returnRequestedAt"].toString()) : undefined as any;
            this.returnConfirmedAt = _data["returnConfirmedAt"] ? new Date(_data["returnConfirmedAt"].toString()) : undefined as any;
            this.lender = _data["lender"] ? UserSummaryDto.fromJS(_data["lender"]) : undefined as any;
            this.borrower = _data["borrower"] ? UserSummaryDto.fromJS(_data["borrower"]) : undefined as any;
            this.item = _data["item"] ? ItemSummaryDto.fromJS(_data["item"]) : undefined as any;
        }
    }

    static fromJS(data: any): LoanListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoanListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["itemId"] = this.itemId;
        data["lenderUserId"] = this.lenderUserId;
        data["borrowerUserId"] = this.borrowerUserId;
        data["requestId"] = this.requestId;
        data["offerId"] = this.offerId;
        data["status"] = this.status;
        data["startAt"] = this.startAt ? this.startAt.toISOString() : undefined as any;
        data["dueAt"] = this.dueAt ? this.dueAt.toISOString() : undefined as any;
        data["returnedAt"] = this.returnedAt ? this.returnedAt.toISOString() : undefined as any;
        data["returnRequestedAt"] = this.returnRequestedAt ? this.returnRequestedAt.toISOString() : undefined as any;
        data["returnConfirmedAt"] = this.returnConfirmedAt ? this.returnConfirmedAt.toISOString() : undefined as any;
        data["lender"] = this.lender ? this.lender.toJSON() : undefined as any;
        data["borrower"] = this.borrower ? this.borrower.toJSON() : undefined as any;
        data["item"] = this.item ? this.item.toJSON() : undefined as any;
        return data;
    }
}

export interface ILoanListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    itemId?: string | undefined;
    lenderUserId?: string | undefined;
    borrowerUserId?: string | undefined;
    requestId?: string | undefined;
    offerId?: string | undefined;
    status?: string | undefined;
    startAt?: Date;
    dueAt?: Date | undefined;
    returnedAt?: Date | undefined;
    returnRequestedAt?: Date | undefined;
    returnConfirmedAt?: Date | undefined;
    lender?: UserSummaryDto;
    borrower?: UserSummaryDto;
    item?: ItemSummaryDto;
}

export class LoanListItemDtoPagedResponseDto implements ILoanListItemDtoPagedResponseDto {
    items?: LoanListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;

    constructor(data?: ILoanListItemDtoPagedResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LoanListItemDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): LoanListItemDtoPagedResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoanListItemDtoPagedResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        return data;
    }
}

export interface ILoanListItemDtoPagedResponseDto {
    items?: LoanListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;
}

export class LoginRequest implements ILoginRequest {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    username?: string | undefined;
    password?: string | undefined;
}

export class MembershipDetailsDto implements IMembershipDetailsDto {
    id?: string | undefined;
    userId?: string | undefined;
    communityId?: string | undefined;
    role?: string | undefined;
    status?: string | undefined;
    invitedByUserId?: string | undefined;
    createdAt?: Date;
    joinedAt?: Date | undefined;
    users?: UserSummaryDto;

    constructor(data?: IMembershipDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.communityId = _data["communityId"];
            this.role = _data["role"];
            this.status = _data["status"];
            this.invitedByUserId = _data["invitedByUserId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.joinedAt = _data["joinedAt"] ? new Date(_data["joinedAt"].toString()) : undefined as any;
            this.users = _data["users"] ? UserSummaryDto.fromJS(_data["users"]) : undefined as any;
        }
    }

    static fromJS(data: any): MembershipDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MembershipDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["communityId"] = this.communityId;
        data["role"] = this.role;
        data["status"] = this.status;
        data["invitedByUserId"] = this.invitedByUserId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["joinedAt"] = this.joinedAt ? this.joinedAt.toISOString() : undefined as any;
        data["users"] = this.users ? this.users.toJSON() : undefined as any;
        return data;
    }
}

export interface IMembershipDetailsDto {
    id?: string | undefined;
    userId?: string | undefined;
    communityId?: string | undefined;
    role?: string | undefined;
    status?: string | undefined;
    invitedByUserId?: string | undefined;
    createdAt?: Date;
    joinedAt?: Date | undefined;
    users?: UserSummaryDto;
}

export class MembershipListItemDto implements IMembershipListItemDto {
    id?: string | undefined;
    userId?: string | undefined;
    communityId?: string | undefined;
    role?: string | undefined;
    status?: string | undefined;
    invitedByUserId?: string | undefined;
    createdAt?: Date;
    joinedAt?: Date | undefined;
    users?: UserSummaryDto;

    constructor(data?: IMembershipListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.communityId = _data["communityId"];
            this.role = _data["role"];
            this.status = _data["status"];
            this.invitedByUserId = _data["invitedByUserId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.joinedAt = _data["joinedAt"] ? new Date(_data["joinedAt"].toString()) : undefined as any;
            this.users = _data["users"] ? UserSummaryDto.fromJS(_data["users"]) : undefined as any;
        }
    }

    static fromJS(data: any): MembershipListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MembershipListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["communityId"] = this.communityId;
        data["role"] = this.role;
        data["status"] = this.status;
        data["invitedByUserId"] = this.invitedByUserId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["joinedAt"] = this.joinedAt ? this.joinedAt.toISOString() : undefined as any;
        data["users"] = this.users ? this.users.toJSON() : undefined as any;
        return data;
    }
}

export interface IMembershipListItemDto {
    id?: string | undefined;
    userId?: string | undefined;
    communityId?: string | undefined;
    role?: string | undefined;
    status?: string | undefined;
    invitedByUserId?: string | undefined;
    createdAt?: Date;
    joinedAt?: Date | undefined;
    users?: UserSummaryDto;
}

export class NotificationDetailsDto implements INotificationDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    type?: NotificationType;
    eventId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    payload?: string | undefined;
    status?: NotificationStatus;
    createdAt?: Date;
    readAt?: Date | undefined;

    constructor(data?: INotificationDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.type = _data["type"];
            this.eventId = _data["eventId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.payload = _data["payload"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.readAt = _data["readAt"] ? new Date(_data["readAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): NotificationDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["type"] = this.type;
        data["eventId"] = this.eventId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["payload"] = this.payload;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["readAt"] = this.readAt ? this.readAt.toISOString() : undefined as any;
        return data;
    }
}

export interface INotificationDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    type?: NotificationType;
    eventId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    payload?: string | undefined;
    status?: NotificationStatus;
    createdAt?: Date;
    readAt?: Date | undefined;
}

export class NotificationListItemDto implements INotificationListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    type?: NotificationType;
    eventId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    status?: NotificationStatus;
    createdAt?: Date;
    readAt?: Date | undefined;

    constructor(data?: INotificationListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.type = _data["type"];
            this.eventId = _data["eventId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.readAt = _data["readAt"] ? new Date(_data["readAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): NotificationListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["type"] = this.type;
        data["eventId"] = this.eventId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["readAt"] = this.readAt ? this.readAt.toISOString() : undefined as any;
        return data;
    }
}

export interface INotificationListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    type?: NotificationType;
    eventId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    status?: NotificationStatus;
    createdAt?: Date;
    readAt?: Date | undefined;
}

export class NotificationListItemDtoPagedResult implements INotificationListItemDtoPagedResult {
    items?: NotificationListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;

    constructor(data?: INotificationListItemDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NotificationListItemDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): NotificationListItemDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListItemDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        return data;
    }
}

export interface INotificationListItemDtoPagedResult {
    items?: NotificationListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;
}

export class NotificationMarkReadRequestDto implements INotificationMarkReadRequestDto {
    ids?: string[] | undefined;

    constructor(data?: INotificationMarkReadRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationMarkReadRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationMarkReadRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface INotificationMarkReadRequestDto {
    ids?: string[] | undefined;
}

export enum NotificationStatus {
    Pending = "Pending",
    Delivered = "Delivered",
}

export enum NotificationType {
    OfferReceivedToRequester = "OfferReceivedToRequester",
    OfferAcceptedToLender = "OfferAcceptedToLender",
    OfferRejectedToLender = "OfferRejectedToLender",
    OfferWithdrawnToRequester = "OfferWithdrawnToRequester",
    LoanReservedToBorrower = "LoanReservedToBorrower",
    LoanReservedToLender = "LoanReservedToLender",
    LoanStartedToBorrower = "LoanStartedToBorrower",
    LoanReturnRequestedToLender = "LoanReturnRequestedToLender",
    LoanReturnConfirmedToBorrower = "LoanReturnConfirmedToBorrower",
    LoanReturnConfirmedToLender = "LoanReturnConfirmedToLender",
    LoanReturnCanceledToLender = "LoanReturnCanceledToLender",
}

export class OfferDetailsDto implements IOfferDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    offererUserId?: string | undefined;
    requestId?: string | undefined;
    itemId?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    community?: CommunitySummaryDto;
    offerer?: UserSummaryDto;

    constructor(data?: IOfferDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.offererUserId = _data["offererUserId"];
            this.requestId = _data["requestId"];
            this.itemId = _data["itemId"];
            this.message = _data["message"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.community = _data["community"] ? CommunitySummaryDto.fromJS(_data["community"]) : undefined as any;
            this.offerer = _data["offerer"] ? UserSummaryDto.fromJS(_data["offerer"]) : undefined as any;
        }
    }

    static fromJS(data: any): OfferDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["offererUserId"] = this.offererUserId;
        data["requestId"] = this.requestId;
        data["itemId"] = this.itemId;
        data["message"] = this.message;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["community"] = this.community ? this.community.toJSON() : undefined as any;
        data["offerer"] = this.offerer ? this.offerer.toJSON() : undefined as any;
        return data;
    }
}

export interface IOfferDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    offererUserId?: string | undefined;
    requestId?: string | undefined;
    itemId?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    community?: CommunitySummaryDto;
    offerer?: UserSummaryDto;
}

export class OfferListItemDto implements IOfferListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    offererUserId?: string | undefined;
    requestId?: string | undefined;
    itemId?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    community?: CommunitySummaryDto;
    offerer?: UserSummaryDto;

    constructor(data?: IOfferListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.offererUserId = _data["offererUserId"];
            this.requestId = _data["requestId"];
            this.itemId = _data["itemId"];
            this.message = _data["message"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.community = _data["community"] ? CommunitySummaryDto.fromJS(_data["community"]) : undefined as any;
            this.offerer = _data["offerer"] ? UserSummaryDto.fromJS(_data["offerer"]) : undefined as any;
        }
    }

    static fromJS(data: any): OfferListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["offererUserId"] = this.offererUserId;
        data["requestId"] = this.requestId;
        data["itemId"] = this.itemId;
        data["message"] = this.message;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["community"] = this.community ? this.community.toJSON() : undefined as any;
        data["offerer"] = this.offerer ? this.offerer.toJSON() : undefined as any;
        return data;
    }
}

export interface IOfferListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    offererUserId?: string | undefined;
    requestId?: string | undefined;
    itemId?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    community?: CommunitySummaryDto;
    offerer?: UserSummaryDto;
}

export class OfferListItemDtoPagedResponseDto implements IOfferListItemDtoPagedResponseDto {
    items?: OfferListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;

    constructor(data?: IOfferListItemDtoPagedResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OfferListItemDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): OfferListItemDtoPagedResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferListItemDtoPagedResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        return data;
    }
}

export interface IOfferListItemDtoPagedResponseDto {
    items?: OfferListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;
}

export class OfferStatusResponseDto implements IOfferStatusResponseDto {
    id?: string | undefined;
    status?: string | undefined;

    constructor(data?: IOfferStatusResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): OfferStatusResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferStatusResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

export interface IOfferStatusResponseDto {
    id?: string | undefined;
    status?: string | undefined;
}

export class RecoveryRequest implements IRecoveryRequest {
    email?: string | undefined;

    constructor(data?: IRecoveryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RecoveryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RecoveryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IRecoveryRequest {
    email?: string | undefined;
}

export class RefreshTokenDto implements IRefreshTokenDto {
    newRefreshToken?: string | undefined;
    refreshTokenExpiresAt?: Date;
    accessToken?: AccessTokenResult;
    user?: UserDto;

    constructor(data?: IRefreshTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newRefreshToken = _data["newRefreshToken"];
            this.refreshTokenExpiresAt = _data["refreshTokenExpiresAt"] ? new Date(_data["refreshTokenExpiresAt"].toString()) : undefined as any;
            this.accessToken = _data["accessToken"] ? AccessTokenResult.fromJS(_data["accessToken"]) : undefined as any;
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): RefreshTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newRefreshToken"] = this.newRefreshToken;
        data["refreshTokenExpiresAt"] = this.refreshTokenExpiresAt ? this.refreshTokenExpiresAt.toISOString() : undefined as any;
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface IRefreshTokenDto {
    newRefreshToken?: string | undefined;
    refreshTokenExpiresAt?: Date;
    accessToken?: AccessTokenResult;
    user?: UserDto;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken?: string | undefined;
    token?: string | undefined;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        data["token"] = this.token;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken?: string | undefined;
    token?: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IRegisterRequest {
    username?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
}

export class ReputationDetailsDto implements IReputationDetailsDto {
    communityId?: string | undefined;
    userId?: string | undefined;
    score?: number;
    lendCount?: number;
    returnCount?: number;
    onTimeReturnCount?: number;
    weights?: ReputationWeightsDto;

    constructor(data?: IReputationDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.userId = _data["userId"];
            this.score = _data["score"];
            this.lendCount = _data["lendCount"];
            this.returnCount = _data["returnCount"];
            this.onTimeReturnCount = _data["onTimeReturnCount"];
            this.weights = _data["weights"] ? ReputationWeightsDto.fromJS(_data["weights"]) : undefined as any;
        }
    }

    static fromJS(data: any): ReputationDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReputationDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["userId"] = this.userId;
        data["score"] = this.score;
        data["lendCount"] = this.lendCount;
        data["returnCount"] = this.returnCount;
        data["onTimeReturnCount"] = this.onTimeReturnCount;
        data["weights"] = this.weights ? this.weights.toJSON() : undefined as any;
        return data;
    }
}

export interface IReputationDetailsDto {
    communityId?: string | undefined;
    userId?: string | undefined;
    score?: number;
    lendCount?: number;
    returnCount?: number;
    onTimeReturnCount?: number;
    weights?: ReputationWeightsDto;
}

export class ReputationWeightsDto implements IReputationWeightsDto {
    lendPoints?: number;
    returnPoints?: number;
    onTimeReturnBonus?: number;

    constructor(data?: IReputationWeightsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lendPoints = _data["lendPoints"];
            this.returnPoints = _data["returnPoints"];
            this.onTimeReturnBonus = _data["onTimeReturnBonus"];
        }
    }

    static fromJS(data: any): ReputationWeightsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReputationWeightsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lendPoints"] = this.lendPoints;
        data["returnPoints"] = this.returnPoints;
        data["onTimeReturnBonus"] = this.onTimeReturnBonus;
        return data;
    }
}

export interface IReputationWeightsDto {
    lendPoints?: number;
    returnPoints?: number;
    onTimeReturnBonus?: number;
}

export class RequestDetailsDto implements IRequestDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    requesterUserId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    neededFrom?: Date | undefined;
    neededTo?: Date | undefined;
    community?: CommunitySummaryDto;
    owner?: UserSummaryDto;

    constructor(data?: IRequestDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.requesterUserId = _data["requesterUserId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.neededFrom = _data["neededFrom"] ? new Date(_data["neededFrom"].toString()) : undefined as any;
            this.neededTo = _data["neededTo"] ? new Date(_data["neededTo"].toString()) : undefined as any;
            this.community = _data["community"] ? CommunitySummaryDto.fromJS(_data["community"]) : undefined as any;
            this.owner = _data["owner"] ? UserSummaryDto.fromJS(_data["owner"]) : undefined as any;
        }
    }

    static fromJS(data: any): RequestDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["requesterUserId"] = this.requesterUserId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["neededFrom"] = this.neededFrom ? this.neededFrom.toISOString() : undefined as any;
        data["neededTo"] = this.neededTo ? this.neededTo.toISOString() : undefined as any;
        data["community"] = this.community ? this.community.toJSON() : undefined as any;
        data["owner"] = this.owner ? this.owner.toJSON() : undefined as any;
        return data;
    }
}

export interface IRequestDetailsDto {
    id?: string | undefined;
    communityId?: string | undefined;
    requesterUserId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    neededFrom?: Date | undefined;
    neededTo?: Date | undefined;
    community?: CommunitySummaryDto;
    owner?: UserSummaryDto;
}

export class RequestListItemDto implements IRequestListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    requesterUserId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    neededFrom?: Date | undefined;
    neededTo?: Date | undefined;
    community?: CommunitySummaryDto;
    owner?: UserSummaryDto;

    constructor(data?: IRequestListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.communityId = _data["communityId"];
            this.requesterUserId = _data["requesterUserId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.neededFrom = _data["neededFrom"] ? new Date(_data["neededFrom"].toString()) : undefined as any;
            this.neededTo = _data["neededTo"] ? new Date(_data["neededTo"].toString()) : undefined as any;
            this.community = _data["community"] ? CommunitySummaryDto.fromJS(_data["community"]) : undefined as any;
            this.owner = _data["owner"] ? UserSummaryDto.fromJS(_data["owner"]) : undefined as any;
        }
    }

    static fromJS(data: any): RequestListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["communityId"] = this.communityId;
        data["requesterUserId"] = this.requesterUserId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["neededFrom"] = this.neededFrom ? this.neededFrom.toISOString() : undefined as any;
        data["neededTo"] = this.neededTo ? this.neededTo.toISOString() : undefined as any;
        data["community"] = this.community ? this.community.toJSON() : undefined as any;
        data["owner"] = this.owner ? this.owner.toJSON() : undefined as any;
        return data;
    }
}

export interface IRequestListItemDto {
    id?: string | undefined;
    communityId?: string | undefined;
    requesterUserId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    neededFrom?: Date | undefined;
    neededTo?: Date | undefined;
    community?: CommunitySummaryDto;
    owner?: UserSummaryDto;
}

export class RequestListItemDtoPagedResponseDto implements IRequestListItemDtoPagedResponseDto {
    items?: RequestListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;

    constructor(data?: IRequestListItemDtoPagedResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestListItemDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): RequestListItemDtoPagedResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestListItemDtoPagedResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        return data;
    }
}

export interface IRequestListItemDtoPagedResponseDto {
    items?: RequestListItemDto[] | undefined;
    page?: number;
    pageSize?: number;
    total?: number;
}

export class ResendVerificationRequest implements IResendVerificationRequest {
    email?: string | undefined;

    constructor(data?: IResendVerificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendVerificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendVerificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendVerificationRequest {
    email?: string | undefined;
}

export class ResetPasswordDto implements IResetPasswordDto {
    token?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IResetPasswordDto {
    token?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class UpdateCommunityRequestDto implements IUpdateCommunityRequestDto {
    name?: string | undefined;
    slug?: string | undefined;
    createdByUserId?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateCommunityRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.createdByUserId = _data["createdByUserId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateCommunityRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommunityRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["createdByUserId"] = this.createdByUserId;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateCommunityRequestDto {
    name?: string | undefined;
    slug?: string | undefined;
    createdByUserId?: string | undefined;
    description?: string | undefined;
}

export class UpdateEventRequestDto implements IUpdateEventRequestDto {
    communityId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    action?: string | undefined;
    payload?: string | undefined;

    constructor(data?: IUpdateEventRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.action = _data["action"];
            this.payload = _data["payload"];
        }
    }

    static fromJS(data: any): UpdateEventRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEventRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["action"] = this.action;
        data["payload"] = this.payload;
        return data;
    }
}

export interface IUpdateEventRequestDto {
    communityId?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    action?: string | undefined;
    payload?: string | undefined;
}

export class UpdateItemRequestDto implements IUpdateItemRequestDto {
    communityId?: string | undefined;
    ownerUserId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;

    constructor(data?: IUpdateItemRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.ownerUserId = _data["ownerUserId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateItemRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateItemRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["ownerUserId"] = this.ownerUserId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateItemRequestDto {
    communityId?: string | undefined;
    ownerUserId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    category?: string | undefined;
    status?: string | undefined;
}

export class UpdateLoanRequestDto implements IUpdateLoanRequestDto {
    communityId?: string | undefined;
    itemId?: string | undefined;
    lenderUserId?: string | undefined;
    borrowerUserId?: string | undefined;
    requestId?: string | undefined;
    offerId?: string | undefined;
    status?: string | undefined;
    startAt?: Date | undefined;
    dueAt?: Date | undefined;
    returnedAt?: Date | undefined;

    constructor(data?: IUpdateLoanRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.itemId = _data["itemId"];
            this.lenderUserId = _data["lenderUserId"];
            this.borrowerUserId = _data["borrowerUserId"];
            this.requestId = _data["requestId"];
            this.offerId = _data["offerId"];
            this.status = _data["status"];
            this.startAt = _data["startAt"] ? new Date(_data["startAt"].toString()) : undefined as any;
            this.dueAt = _data["dueAt"] ? new Date(_data["dueAt"].toString()) : undefined as any;
            this.returnedAt = _data["returnedAt"] ? new Date(_data["returnedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UpdateLoanRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLoanRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["itemId"] = this.itemId;
        data["lenderUserId"] = this.lenderUserId;
        data["borrowerUserId"] = this.borrowerUserId;
        data["requestId"] = this.requestId;
        data["offerId"] = this.offerId;
        data["status"] = this.status;
        data["startAt"] = this.startAt ? this.startAt.toISOString() : undefined as any;
        data["dueAt"] = this.dueAt ? this.dueAt.toISOString() : undefined as any;
        data["returnedAt"] = this.returnedAt ? this.returnedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IUpdateLoanRequestDto {
    communityId?: string | undefined;
    itemId?: string | undefined;
    lenderUserId?: string | undefined;
    borrowerUserId?: string | undefined;
    requestId?: string | undefined;
    offerId?: string | undefined;
    status?: string | undefined;
    startAt?: Date | undefined;
    dueAt?: Date | undefined;
    returnedAt?: Date | undefined;
}

export class UpdateMembershipRequestDto implements IUpdateMembershipRequestDto {
    userId?: string | undefined;
    communityId?: string | undefined;
    role?: string | undefined;
    status?: string | undefined;
    invitedByUserId?: string | undefined;
    joinedAt?: Date | undefined;

    constructor(data?: IUpdateMembershipRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.communityId = _data["communityId"];
            this.role = _data["role"];
            this.status = _data["status"];
            this.invitedByUserId = _data["invitedByUserId"];
            this.joinedAt = _data["joinedAt"] ? new Date(_data["joinedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UpdateMembershipRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMembershipRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["communityId"] = this.communityId;
        data["role"] = this.role;
        data["status"] = this.status;
        data["invitedByUserId"] = this.invitedByUserId;
        data["joinedAt"] = this.joinedAt ? this.joinedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IUpdateMembershipRequestDto {
    userId?: string | undefined;
    communityId?: string | undefined;
    role?: string | undefined;
    status?: string | undefined;
    invitedByUserId?: string | undefined;
    joinedAt?: Date | undefined;
}

export class UpdateMembershipRoleRequestDto implements IUpdateMembershipRoleRequestDto {
    role?: string | undefined;

    constructor(data?: IUpdateMembershipRoleRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UpdateMembershipRoleRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMembershipRoleRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role;
        return data;
    }
}

export interface IUpdateMembershipRoleRequestDto {
    role?: string | undefined;
}

export class UpdateOfferRequestDto implements IUpdateOfferRequestDto {
    communityId?: string | undefined;
    offererUserId?: string | undefined;
    requestId?: string | undefined;
    itemId?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;

    constructor(data?: IUpdateOfferRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.offererUserId = _data["offererUserId"];
            this.requestId = _data["requestId"];
            this.itemId = _data["itemId"];
            this.message = _data["message"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateOfferRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOfferRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["offererUserId"] = this.offererUserId;
        data["requestId"] = this.requestId;
        data["itemId"] = this.itemId;
        data["message"] = this.message;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateOfferRequestDto {
    communityId?: string | undefined;
    offererUserId?: string | undefined;
    requestId?: string | undefined;
    itemId?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;
}

export class UpdateRequestRequestDto implements IUpdateRequestRequestDto {
    communityId?: string | undefined;
    requesterUserId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    neededFrom?: Date | undefined;
    neededTo?: Date | undefined;

    constructor(data?: IUpdateRequestRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communityId = _data["communityId"];
            this.requesterUserId = _data["requesterUserId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.neededFrom = _data["neededFrom"] ? new Date(_data["neededFrom"].toString()) : undefined as any;
            this.neededTo = _data["neededTo"] ? new Date(_data["neededTo"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UpdateRequestRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRequestRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communityId"] = this.communityId;
        data["requesterUserId"] = this.requesterUserId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["status"] = this.status;
        data["neededFrom"] = this.neededFrom ? this.neededFrom.toISOString() : undefined as any;
        data["neededTo"] = this.neededTo ? this.neededTo.toISOString() : undefined as any;
        return data;
    }
}

export interface IUpdateRequestRequestDto {
    communityId?: string | undefined;
    requesterUserId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: string | undefined;
    neededFrom?: Date | undefined;
    neededTo?: Date | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    username?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.name = _data["name"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["name"] = this.name;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IUserDto {
    id?: string | undefined;
    username?: string | undefined;
    name?: string | undefined;
    lastName?: string | undefined;
}

export class UserSummaryDto implements IUserSummaryDto {
    id?: string | undefined;
    displayName?: string | undefined;
    userName?: string | undefined;
    avatarUrl?: string | undefined;

    constructor(data?: IUserSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.userName = _data["userName"];
            this.avatarUrl = _data["avatarUrl"];
        }
    }

    static fromJS(data: any): UserSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["userName"] = this.userName;
        data["avatarUrl"] = this.avatarUrl;
        return data;
    }
}

export interface IUserSummaryDto {
    id?: string | undefined;
    displayName?: string | undefined;
    userName?: string | undefined;
    avatarUrl?: string | undefined;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}